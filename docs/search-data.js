window.Aiken.initSearch([{"doc":"aiken/math","title":"abs","content":"abs(self: Int) -&gt; Int\n Calculate the absolute value of an integer.\n\n ```aiken\n use aiken/math\n\n math.abs(-42)\n // 42\n\n math.abs(14)\n // 14\n ```","url":"aiken/math.html#abs"},{"doc":"aiken/math","title":"clamp","content":"clamp(self: Int, min: Int, max: Int) -&gt; Int\n Restrict the value of an integer between two min and max bounds\n\n ```aiken\n use aiken/math\n\n math.clamp(14, min: 0, max: 10)\n // 10\n ```","url":"aiken/math.html#clamp"},{"doc":"aiken/math","title":"max","content":"max(a: Int, b: Int) -&gt; Int\n Return the maximum of two integers.","url":"aiken/math.html#max"},{"doc":"aiken/math","title":"min","content":"min(a: Int, b: Int) -&gt; Int\n Return the minimum of two integers.","url":"aiken/math.html#min"},{"doc":"aiken/math","title":"aiken/math","content":" This module contains some basic Math utilities. Standard arithmetic\n operations on integers are available through native operators:\n\n operator | Description\n ---      | ---\n +        | Arithmetic sum\n -        | Arithmetic difference\n /        | Whole division\n *        | Arithmetic multiplication\n %        | Remainder by whole division\n\n Here are a few examples:\n\n ```aiken\n 1 + 1   // 2\n 10 - 2  // 8\n 40 / 14 // 2\n 3 * 4   // 12\n 10 % 3  // 1","url":"aiken/math.html"},{"doc":"collateral","title":"check_if_contains_enough_of_value","content":"check_if_contains_enough_of_value(\n  value: Value,\n  asset_tuple: (ByteArray, ByteArray, Int),\n) -&gt; Bool\n","url":"collateral.html#check_if_contains_enough_of_value"},{"doc":"collateral","title":"keyhash_address","content":"keyhash_address(keyhash: ByteArray) -&gt; Address\n","url":"collateral.html#keyhash_address"},{"doc":"collateral","title":"own_validator_script_address_hash","content":"own_validator_script_address_hash(\n  inputs: List&lt;Input&gt;,\n  output_reference: OutputReference,\n) -&gt; Option&lt;ValidatorHash&gt;\n","url":"collateral.html#own_validator_script_address_hash"},{"doc":"collateral","title":"scripthash_address","content":"scripthash_address(scripthash: ByteArray) -&gt; Address\n","url":"collateral.html#scripthash_address"},{"doc":"collateral","title":"validate_contract_output","content":"validate_contract_output(\n  ctx: ScriptContext,\n  expected_datum: InterestDatum,\n  expected_value: Value,\n  contract_address: Address,\n) -&gt; Bool\n","url":"collateral.html#validate_contract_output"},{"doc":"collateral","title":"CurrencySymbol","content":"CurrencySymbol {\n  policy_id: PolicyId,\n  asset_name: AssetName,\n}\n\nCurrencySymbol { policy_id: PolicyId, asset_name: AssetName }\n","url":"collateral.html#CurrencySymbol"},{"doc":"collateral","title":"InterestDatum","content":"InterestDatum {\n  lender_tn: AssetName,\n}\n\nInterestDatum { lender_tn: AssetName }\n","url":"collateral.html#InterestDatum"},{"doc":"collateral","title":"RequestDatum","content":"RequestDatum {\n  borrower_tn: AssetName,\n  borrower_address: Address,\n  loan_asset: CurrencySymbol,\n  loan_amount: Int,\n  interest_asset: CurrencySymbol,\n  interest_amount: Int,\n  collateral_asset: CurrencySymbol,\n  collateral_amount: Int,\n  loan_duration: Int,\n  liquidate_nft: PolicyId,\n  collateral_factor: Int,\n  liquidation_commision: Int,\n  request_expiration_time: POSIXTime,\n  lender_tn: AssetName,\n  lend_date: Int,\n}\n\nRequestDatum {\n  borrower_tn: AssetName,\n  borrower_address: Address,\n  loan_asset: CurrencySymbol,\n  loan_amount: Int,\n  interest_asset: CurrencySymbol,\n  interest_amount: Int,\n  collateral_asset: CurrencySymbol,\n  collateral_amount: Int,\n  loan_duration: Int,\n  liquidate_nft: PolicyId,\n  collateral_factor: Int,\n  liquidation_commision: Int,\n  request_expiration_time: POSIXTime,\n  lender_tn: AssetName,\n  lend_date: Int,\n}\n","url":"collateral.html#RequestDatum"},{"doc":"collateral","title":"ValidatorHash","content":"ValidatorHash = Hash&lt;Blake2b_224, Script&gt;\n\n","url":"collateral.html#ValidatorHash"},{"doc":"collateral","title":"collateral","content":"","url":"collateral.html"},{"doc":"test_minter","title":"test_minter","content":"","url":"test_minter.html"},{"doc":"v2_pool","title":"correct_details_saved","content":"correct_details_saved(\n  ctx: ScriptContext,\n  lender_tn: AssetName,\n  script_address: Address,\n  lower_validity_range: Int,\n) -&gt; Bool\n","url":"v2_pool.html#correct_details_saved"},{"doc":"v2_pool","title":"get_lower_bound","content":"get_lower_bound(range: ValidityRange) -&gt; Int\n","url":"v2_pool.html#get_lower_bound"},{"doc":"v2_pool","title":"paid_to_address","content":"paid_to_address(\n  tx_output: List&lt;Output&gt;,\n  address: Address,\n  policy_id: PolicyId,\n  token_name: AssetName,\n  amount: Int,\n) -&gt; Bool\n","url":"v2_pool.html#paid_to_address"},{"doc":"v2_pool","title":"scripthash_address","content":"scripthash_address(scripthash: ByteArray) -&gt; Address\n","url":"v2_pool.html#scripthash_address"},{"doc":"v2_pool","title":"validate_pool_borrow","content":"validate_pool_borrow(\n  ctx: ScriptContext,\n  output_reference: OutputReference,\n  datum: PoolDatum,\n  redeemer: PoolBorrowRedeemer,\n) -&gt; Bool\n","url":"v2_pool.html#validate_pool_borrow"},{"doc":"v2_pool","title":"validate_pool_deposit","content":"validate_pool_deposit(\n  ctx: ScriptContext,\n  output_reference: OutputReference,\n  datum: PoolDatum,\n  redeemer: PoolDepositRedeemer,\n) -&gt; Bool\n","url":"v2_pool.html#validate_pool_deposit"},{"doc":"v2_pool","title":"CurrencySymbol","content":"CurrencySymbol {\n  policy_id: PolicyId,\n  asset_name: AssetName,\n}\n\nCurrencySymbol { policy_id: PolicyId, asset_name: AssetName }\n","url":"v2_pool.html#CurrencySymbol"},{"doc":"v2_pool","title":"DepositRedeemer","content":"DepositRedeemer {\n  lender_token_name: AssetName,\n  lower_validity_range: Int,\n}\n\nDepositRedeemer { lender_token_name: AssetName, lower_validity_range: Int }\n","url":"v2_pool.html#DepositRedeemer"},{"doc":"v2_pool","title":"LenderDetailsDatum","content":"LenderDetailsDatum {\n  lender_tn: AssetName,\n  deposit_time: Int,\n}\n\nLenderDetailsDatum { lender_tn: AssetName, deposit_time: Int }\n","url":"v2_pool.html#LenderDetailsDatum"},{"doc":"v2_pool","title":"OrderDatum","content":"OrderDatum {\n  depositor_address: Address,\n}\n\nOrderDatum { depositor_address: Address }\n","url":"v2_pool.html#OrderDatum"},{"doc":"v2_pool","title":"OrderRedeemerType","content":"OrderRedeemerType {\n  Cancel(Int)\n  Deposit(DepositRedeemer)\n}\n\nCancel(Int)\n\nDeposit(DepositRedeemer)\n","url":"v2_pool.html#OrderRedeemerType"},{"doc":"v2_pool","title":"PoolBorrowRedeemer","content":"PoolBorrowRedeemer {\n  input_cs: CurrencySymbol,\n  input_amount: Int,\n}\n\nPoolBorrowRedeemer { input_cs: CurrencySymbol, input_amount: Int }\n","url":"v2_pool.html#PoolBorrowRedeemer"},{"doc":"v2_pool","title":"PoolDatum","content":"PoolDatum {\n  currency_symbol: CurrencySymbol,\n  balance: Int,\n  lent_out: Int,\n}\n\nPoolDatum { currency_symbol: CurrencySymbol, balance: Int, lent_out: Int }\n","url":"v2_pool.html#PoolDatum"},{"doc":"v2_pool","title":"PoolDepositRedeemer","content":"PoolDepositRedeemer {\n  input_cs: CurrencySymbol,\n  input_amount: Int,\n}\n\nPoolDepositRedeemer { input_cs: CurrencySymbol, input_amount: Int }\n","url":"v2_pool.html#PoolDepositRedeemer"},{"doc":"v2_pool","title":"PoolRedeemerType","content":"PoolRedeemerType {\n  PoolWithdraw(Int)\n  PoolDeposit(PoolDepositRedeemer)\n  PoolBorrow(PoolBorrowRedeemer)\n}\n\nPoolWithdraw(Int)\n\nPoolDeposit(PoolDepositRedeemer)\n\nPoolBorrow(PoolBorrowRedeemer)\n","url":"v2_pool.html#PoolRedeemerType"},{"doc":"v2_pool","title":"v2_pool","content":" Allow to consume from validator in 2 ocasions:\n 1. Lender is canceling the request (signed by lender)\n 2. Batched correctly and lender receives what expected","url":"v2_pool.html"},{"doc":"aiken/interval","title":"after","content":"after(lower_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values greater than the given bound. i.e [lower_bound, +INF)","url":"aiken/interval.html#after"},{"doc":"aiken/interval","title":"before","content":"before(upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values greater than the given bound. i.e (-INF, upper_bound]","url":"aiken/interval.html#before"},{"doc":"aiken/interval","title":"between","content":"between(lower_bound: a, upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values between two bounds, including the bounds. i.e. [lower_bound, upper_bound]","url":"aiken/interval.html#between"},{"doc":"aiken/interval","title":"contains","content":"contains(self: Interval&lt;Int&gt;, elem: Int) -&gt; Bool\n Checks whether an element is contained within the interval.\n\n ```aiken\n use aiken/interval.{Interval, IntervalBound, Finite}\n\n let iv =\n   Interval {\n     lower_bound: IntervalBound(Finite(14), True),\n     upper_bound: IntervalBound(Finite(42), False),\n   }\n\n contains(iv, 25) // True\n contains(iv, 0)  // False\n contains(iv, 14) // True\n contains(iv, 42) // False\n ```","url":"aiken/interval.html#contains"},{"doc":"aiken/interval","title":"empty","content":"empty() -&gt; Interval&lt;a&gt;\n Create an empty interval that contains no value.","url":"aiken/interval.html#empty"},{"doc":"aiken/interval","title":"everything","content":"everything() -&gt; Interval&lt;a&gt;\n Create an interval that contains every possible values. i.e. (-INF, +INF)","url":"aiken/interval.html#everything"},{"doc":"aiken/interval","title":"hull","content":"hull(iv1: Interval&lt;Int&gt;, iv2: Interval&lt;Int&gt;) -&gt; Interval&lt;Int&gt;\n Computes the smallest interval containing the two given intervals, if any\n\n ## Examples\n\n ```aiken\n let iv1 = between(0, 10)\n let iv2 = between(2, 14)\n hull(iv1, iv2) == between(0, 14)\n\n let iv1 = between(5, 10)\n let iv2 = before(0)\n hull(iv1, iv2) == before(10)\n\n let iv1 = strictly_after(0)\n let iv2 = between(10, 42)\n hull(iv1, iv2) = strictly_after(0)\n ```","url":"aiken/interval.html#hull"},{"doc":"aiken/interval","title":"intersection","content":"intersection(iv1: Interval&lt;Int&gt;, iv2: Interval&lt;Int&gt;) -&gt; Interval&lt;Int&gt;\n Computes the largest interval contains in the two given intervals, if any.\n\n ## Examples\n\n ```aiken\n let iv1 = between(0, 10)\n let iv2 = between(2, 14)\n intersection(iv1, iv2) == between(2, 10)\n\n let iv1 = strictly_before(10)\n let iv2 = strictly_after(0)\n intersection(iv1, iv2) == strictly_between(0, 10)\n\n let iv1 = between(0, 1)\n let iv2 = between(2, 3)\n intersection(iv1, iv2) |&gt; is_empty\n ```","url":"aiken/interval.html#intersection"},{"doc":"aiken/interval","title":"is_empty","content":"is_empty(self: Interval&lt;Int&gt;) -&gt; Bool\n Tells whether an interval is empty; i.e. that is contains no value.","url":"aiken/interval.html#is_empty"},{"doc":"aiken/interval","title":"max","content":"max(left: IntervalBound&lt;Int&gt;, right: IntervalBound&lt;Int&gt;) -&gt; IntervalBound&lt;Int&gt;\n Return the highest bound of the two.","url":"aiken/interval.html#max"},{"doc":"aiken/interval","title":"min","content":"min(left: IntervalBound&lt;Int&gt;, right: IntervalBound&lt;Int&gt;) -&gt; IntervalBound&lt;Int&gt;\n Return the smallest bound of the two.","url":"aiken/interval.html#min"},{"doc":"aiken/interval","title":"strictly_after","content":"strictly_after(lower_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values strictly greater than the given bound, excluding the bound itself. i.e (lower_bound, +INF)","url":"aiken/interval.html#strictly_after"},{"doc":"aiken/interval","title":"strictly_before","content":"strictly_before(upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values strictly greater than the given bound, excluding the bound itself. i.e (-INF, upper_bound)","url":"aiken/interval.html#strictly_before"},{"doc":"aiken/interval","title":"strictly_between","content":"strictly_between(lower_bound: a, upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values between two bounds, excluding the bounds. i.e. (lower_bound, upper_bound)","url":"aiken/interval.html#strictly_between"},{"doc":"aiken/interval","title":"Interval","content":"Interval&lt;a&gt; {\n  lower_bound: IntervalBound&lt;a&gt;,\n  upper_bound: IntervalBound&lt;a&gt;,\n}\n A type to represent intervals of values. Interval are inhabited by a type\n `a` which is useful for non-infinite intervals that have a finite\n lower-bound and/or upper-bound.\n\n This allows to represent all kind of mathematical intervals:\n\n ```aiken\n // [1; 10]\n let i0: Interval&lt;Int&gt; = Interval\n   { lower_bound:\n       IntervalBound { bound_type: Finite(1), is_inclusive: True }\n   , upper_bound:\n       IntervalBound { bound_type: Finite(10), is_inclusive: True }\n   }\n ```\n\n ```aiken\n // (20; infinity)\n let i1: Interval&lt;Int&gt; = Interval\n   { lower_bound:\n       IntervalBound { bound_type: Finite(20), is_inclusive: False }\n   , upper_bound:\n       IntervalBound { bound_type: PositiveInfinity, is_inclusive: False }\n   }\n ```\nInterval { lower_bound: IntervalBound&lt;a&gt;, upper_bound: IntervalBound&lt;a&gt; }\n","url":"aiken/interval.html#Interval"},{"doc":"aiken/interval","title":"IntervalBound","content":"IntervalBound&lt;a&gt; {\n  bound_type: IntervalBoundType&lt;a&gt;,\n  is_inclusive: Bool,\n}\n An interval bound, either inclusive or exclusive.\nIntervalBound { bound_type: IntervalBoundType&lt;a&gt;, is_inclusive: Bool }\n","url":"aiken/interval.html#IntervalBound"},{"doc":"aiken/interval","title":"IntervalBoundType","content":"IntervalBoundType&lt;a&gt; {\n  NegativeInfinity\n  Finite(a)\n  PositiveInfinity\n}\n A type of interval bound. Where finite, a value of type `a` must be\n provided. `a` will typically be an `Int`, representing a number of seconds or\n milliseconds.\nNegativeInfinity\n\nFinite(a)\n\nPositiveInfinity\n","url":"aiken/interval.html#IntervalBoundType"},{"doc":"aiken/interval","title":"aiken/interval","content":" In a eUTxO-based blockchain like Cardano, the management of time can be\n finicky.\n\n Indeed, in order to maintain a complete determinism in the execution of\n scripts, it is impossible to introduce a notion of _&quot;current time&quot;_ since\n the execution would then depend on factor that are external to the\n transaction itself: the ineluctable stream of time flowing in our universe.\n\n Hence, to work around that, we typically define time intervals, which gives\n window -- a.k.a intervals -- within which the transaction can be executed.\n From within a script, it isn&#39;t possible to know when exactly the script is\n executed, but we can reason about the interval bounds to validate pieces of\n logic.","url":"aiken/interval.html"},{"doc":"aiken/list","title":"all","content":"all(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; Bool\n Determine if all elements of the list satisfy the given predicate.\n\n Note: an empty list always satisfies the predicate.\n\n ```aiken\n list.all([], fn(n) { n &gt; 0 }) == True\n list.all([1, 2, 3], fn(n) { n &gt; 0 }) == True\n list.all([1, 2, 3], fn(n) { n == 2 }) == False\n ```","url":"aiken/list.html#all"},{"doc":"aiken/list","title":"and","content":"and(self: List&lt;Bool&gt;) -&gt; Bool\n Like [all](#and) but when elements are already booleans.\n\n Note: an empty list always satisfies the predicate.\n\n ```aiken\n list.and([]) == True\n list.and([True, True]) == True\n list.and([True, False]) == False\n ```","url":"aiken/list.html#and"},{"doc":"aiken/list","title":"any","content":"any(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; Bool\n Determine if at least one element of the list satisfies the given predicate.\n\n Note: an empty list never satisfies the predicate.\n\n ```aiken\n list.any([], fn(n) { n &gt; 2 }) == False\n list.any([1, 2, 3], fn(n) { n &gt; 0 }) == True\n list.any([1, 2, 3], fn(n) { n == 2 }) == True\n list.any([1, 2, 3], fn(n) { n &lt; 0 }) == False\n ```","url":"aiken/list.html#any"},{"doc":"aiken/list","title":"at","content":"at(self: List&lt;a&gt;, index: Int) -&gt; Option&lt;a&gt;\n Return Some(item) at the index or None if the index is out of range. The index is 0-based.\n\n ```aiken\n list.at([1, 2, 3], 1) == Some(2)\n list.at([1, 2, 3], 42) == None\n ```","url":"aiken/list.html#at"},{"doc":"aiken/list","title":"concat","content":"concat(left: List&lt;a&gt;, right: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Merge two lists together.\n\n ```aiken\n list.concat([], []) == []\n list.concat([], [1, 2, 3]) == [1, 2, 3]\n list.concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n ```","url":"aiken/list.html#concat"},{"doc":"aiken/list","title":"delete","content":"delete(self: List&lt;a&gt;, elem: a) -&gt; List&lt;a&gt;\n Remove the first occurence of the given element from the list.\n\n ```aiken\n list.delete([1, 2, 3, 1], 1) == [2, 3, 1]\n list.delete([1, 2, 3], 14) == [1, 2, 3]\n ```","url":"aiken/list.html#delete"},{"doc":"aiken/list","title":"difference","content":"difference(self: List&lt;a&gt;, with: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Remove the first occurence of each element of the second list from the first one.\n\n ```\n list.difference([&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;], [&quot;l&quot;, &quot;e&quot;, &quot;l&quot;]) == [&quot;h&quot;, &quot;o&quot;]\n list.difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]\n list.difference([1, 2, 3], []) == [1, 2, 3]\n ```","url":"aiken/list.html#difference"},{"doc":"aiken/list","title":"drop","content":"drop(self: List&lt;a&gt;, n: Int) -&gt; List&lt;a&gt;\n Drop the first `n` elements of a list.\n\n ```aiken\n list.drop([1, 2, 3], 2) == [3]\n list.drop([], 42) == []\n list.drop([1, 2, 3], 42) == []\n ```","url":"aiken/list.html#drop"},{"doc":"aiken/list","title":"drop_while","content":"drop_while(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Returns the suffix of the given list after removing all elements that satisfy the predicate.\n\n ```aiken\n list.drop_while([1, 2, 3], fn(x) { x &gt; 2 }) == [2, 3]\n list.drop_while([], fn(x) { x &gt; 2 }) == []\n list.drop_while([1, 2, 3], fn(x) { x == 3 }) == [1, 2, 3]\n ```","url":"aiken/list.html#drop_while"},{"doc":"aiken/list","title":"filter","content":"filter(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Produce a list of elements that statisfy a predicate.\n\n ```aiken\n list.filter([1, 2, 3], fn(x) { x &gt; 2 }) == [2, 3]\n list.filter([], fn(x) { x &gt; 2 }) == []\n list.filter([1, 2, 3], fn(x) { x == 3 }) == [3]\n ```","url":"aiken/list.html#filter"},{"doc":"aiken/list","title":"filter_map","content":"filter_map(self: List&lt;a&gt;, predicate: fn(a) -&gt; Option&lt;b&gt;) -&gt; List&lt;b&gt;\n Produce a list of transformed elements that statisfy a predicate.\n\n ```aiken\n let transform = fn(x) { if x % 2 == 0 { None } else { Some(3*x) } }\n list.filter_map([1, 2, 3], transform) == [3, 9]\n ```","url":"aiken/list.html#filter_map"},{"doc":"aiken/list","title":"find","content":"find(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; Option&lt;a&gt;\n Find the first element satisfying the given predicate, if any.\n\n ```aiken\n list.find([1, 2, 3], fn(x) { x == 2 }) == Some(2)\n list.find([4, 5, 6], fn(x) { x == 2 }) == None\n ```","url":"aiken/list.html#find"},{"doc":"aiken/list","title":"flat_map","content":"flat_map(self: List&lt;a&gt;, with: fn(a) -&gt; List&lt;b&gt;) -&gt; List&lt;b&gt;\n Map elements of a list into a new list and flatten the result.\n\n ```aiken\n list.flat_map([1, 2, 3], fn(a) { [a, 2*a] }) == [1, 2, 2, 4, 3, 6]\n ```","url":"aiken/list.html#flat_map"},{"doc":"aiken/list","title":"foldl","content":"foldl(self: List&lt;a&gt;, with: fn(a, b) -&gt; b, zero: b) -&gt; b\n Reduce a list from left to right.\n\n ```aiken\n list.foldl([1, 2, 3], fn(n, total) { n + total }, 0) == 6\n list.foldl([1, 2, 3], fn(x, xs) { [x, ..xs] }) == [3, 2, 1]\n ```","url":"aiken/list.html#foldl"},{"doc":"aiken/list","title":"foldr","content":"foldr(self: List&lt;a&gt;, with: fn(a, b) -&gt; b, zero: b) -&gt; b\n Reduce a list from right to left.\n\n ```aiken\n list.foldr([1, 2, 3], fn(n, total) { n + total }, 0) == 6\n list.foldr([1, 2, 3], fn(x, xs) { [x, ..xs] }, 0) == [1, 2, 3]\n ```","url":"aiken/list.html#foldr"},{"doc":"aiken/list","title":"has","content":"has(self: List&lt;a&gt;, elem: a) -&gt; Bool\n Figures out whether a list contain the given element.\n\n ```aiken\n list.has([1, 2, 3], 2) == True\n list.has([1, 2, 3], 14) == False\n list.has([], 14) == False\n ```","url":"aiken/list.html#has"},{"doc":"aiken/list","title":"head","content":"head(self: List&lt;a&gt;) -&gt; Option&lt;a&gt;\n Get the first element of a list\n\n ```aiken\n list.head([1, 2, 3]) == Some(1)\n list.head([]) == None\n ```","url":"aiken/list.html#head"},{"doc":"aiken/list","title":"indexed_foldr","content":"indexed_foldr(\n  self: List&lt;a&gt;,\n  with: fn(Int, a, result) -&gt; result,\n  zero: result,\n) -&gt; result\n Like [`foldr`](#foldr), but also provides the position (0-based) of the elements when iterating.\n\n ```aiken\n let group = fn(i, x, xs) { [(i, x), ..xs] }\n list.indexed_foldr([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], group, []) == [\n   (0, &quot;a&quot;),\n   (1, &quot;b&quot;),\n   (2, &quot;c&quot;)\n ]\n ```","url":"aiken/list.html#indexed_foldr"},{"doc":"aiken/list","title":"indexed_map","content":"indexed_map(self: List&lt;a&gt;, with: fn(Int, a) -&gt; result) -&gt; List&lt;result&gt;\n List [`map`](#map) but provides the position (0-based) of the elements while iterating.\n\n ```aiken\n list.indexed_map([1, 2, 3], fn(i, x) { i + x }) == [1, 3, 5]\n ```","url":"aiken/list.html#indexed_map"},{"doc":"aiken/list","title":"init","content":"init(self: List&lt;a&gt;) -&gt; Option&lt;List&lt;a&gt;&gt;\n Return all elements except the last one.\n\n ```aiken\n list.init([]) == None\n list.init([1, 2, 3]) == Some([1, 2])\n ```","url":"aiken/list.html#init"},{"doc":"aiken/list","title":"is_empty","content":"is_empty(self: List&lt;a&gt;) -&gt; Bool\n Checks whether a list is empty.\n\n ```aiken\n list.is_empty([]) == True\n list.is_empty([1, 2, 3]) == False\n ```","url":"aiken/list.html#is_empty"},{"doc":"aiken/list","title":"last","content":"last(self: List&lt;a&gt;) -&gt; Option&lt;a&gt;\n Get the last in the given list, if any.\n\n ```aiken\n list.last([]) == None\n list.last([1, 2, 3]) == Some(3)\n ```","url":"aiken/list.html#last"},{"doc":"aiken/list","title":"length","content":"length(self: List&lt;a&gt;) -&gt; Int\n Get the number of elements in the given list.\n\n ```aiken\n list.length([]) == 0\n list.length([1, 2, 3]) == 3\n ```","url":"aiken/list.html#length"},{"doc":"aiken/list","title":"map","content":"map(self: List&lt;a&gt;, with: fn(a) -&gt; result) -&gt; List&lt;result&gt;\n Apply a function to each element of a list.\n\n ```aiken\n list.map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]\n ```","url":"aiken/list.html#map"},{"doc":"aiken/list","title":"map2","content":"map2(self: List&lt;a&gt;, bs: List&lt;b&gt;, with: fn(a, b) -&gt; result) -&gt; List&lt;result&gt;\n Apply a function of two arguments, combining elements from two lists.\n\n Note: if one list is longer, the extra elements are dropped.\n\n ```aiken\n list.map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]\n ```","url":"aiken/list.html#map2"},{"doc":"aiken/list","title":"map3","content":"map3(\n  self: List&lt;a&gt;,\n  bs: List&lt;b&gt;,\n  cs: List&lt;c&gt;,\n  with: fn(a, b, c) -&gt; result,\n) -&gt; List&lt;result&gt;\n Apply a function of three arguments, combining elements from three lists.\n\n Note: if one list is longer, the extra elements are dropped.\n\n ```aiken\n list.map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]\n ```","url":"aiken/list.html#map3"},{"doc":"aiken/list","title":"or","content":"or(self: List&lt;Bool&gt;) -&gt; Bool\n Like [any](#any) but when elements are already booleans.\n\n Note: an empty list never satisfies the predicate.\n\n ```aiken\n list.or([]) == False\n list.or([True, True]) == True\n list.or([True, False]) == True\n list.or([False, False]) == False\n ```","url":"aiken/list.html#or"},{"doc":"aiken/list","title":"partition","content":"partition(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; (List&lt;a&gt;, List&lt;a&gt;)\n Returns a tuple with all elements that satisfy the predicate at first\n element, and the rest as second element.\n\n ```aiken\n list.partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])\n ```","url":"aiken/list.html#partition"},{"doc":"aiken/list","title":"push","content":"push(self: List&lt;a&gt;, elem: a) -&gt; List&lt;a&gt;\n Add an element in front of the list. Sometimes useful when combined with\n other functions.\n\n ```aiken\n list.push([2, 3], 1) == [1, ..[2, 3]] == [1, 2, 3]\n ```","url":"aiken/list.html#push"},{"doc":"aiken/list","title":"range","content":"range(from: Int, to: Int) -&gt; List&lt;Int&gt;\n Construct a list of a integer from a given range.\n\n ```aiken\n list.range(0, 3) == [0, 1, 2, 3]\n list.range(-1, 1) == [-1, 0, 1]\n ```","url":"aiken/list.html#range"},{"doc":"aiken/list","title":"repeat","content":"repeat(elem: a, n_times: Int) -&gt; List&lt;a&gt;\n Construct a list filled with n copies of a value.\n\n ```aiken\n list.repeat(&quot;na&quot;, 3) == [&quot;na&quot;, &quot;na&quot;, &quot;na&quot;]\n ```","url":"aiken/list.html#repeat"},{"doc":"aiken/list","title":"reverse","content":"reverse(self: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Return the list with its elements in the reserve order.\n\n ```aiken\n list.reverse([1, 2, 3]) == [3, 2, 1]\n ```","url":"aiken/list.html#reverse"},{"doc":"aiken/list","title":"slice","content":"slice(self: List&lt;a&gt;, from: Int, to: Int) -&gt; List&lt;a&gt;\n Extract a sublist from the given list using 0-based indexes. Negative\n indexes wrap over, so `-1` refers to the last element of the list.\n\n ```aiken\n list.slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]\n list.slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]\n list.slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]\n ```","url":"aiken/list.html#slice"},{"doc":"aiken/list","title":"sort","content":"sort(self: List&lt;a&gt;, compare: fn(a, a) -&gt; Ordering) -&gt; List&lt;a&gt;\n Sort a list in ascending order using the given comparison function.\n\n ```aiken\n use aiken/int\n\n sort([3, 1, 4, 0, 2], int.compare) == [0, 1, 2, 3, 4]\n sort([1, 2, 3], int.compare) == [1, 2, 3]\n ```","url":"aiken/list.html#sort"},{"doc":"aiken/list","title":"span","content":"span(self: List&lt;a&gt;, n: Int) -&gt; (List&lt;a&gt;, List&lt;a&gt;)\n Cut a list in two, such that the first list contains the given number of /\n elements and the second list contains the rest.\n\n Fundamentally equivalent to (but more efficient):\n\n ```aiken\n span(xs, n) == (take(xs, n), drop(xs, n))\n ```","url":"aiken/list.html#span"},{"doc":"aiken/list","title":"tail","content":"tail(self: List&lt;a&gt;) -&gt; Option&lt;List&lt;a&gt;&gt;\n Get elements of a list after the first one, if any.\n\n ```aiken\n list.tail([]) == None\n list.tail([1, 2, 3]) == Some([2, 3])\n ```","url":"aiken/list.html#tail"},{"doc":"aiken/list","title":"take","content":"take(self: List&lt;a&gt;, n: Int) -&gt; List&lt;a&gt;\n Get the first `n` elements of a list.\n\n ```aiken\n list.take([1, 2, 3], 2) == [1, 2]\n list.take([1, 2, 3], 14) == [1, 2, 3]\n ```","url":"aiken/list.html#take"},{"doc":"aiken/list","title":"take_while","content":"take_while(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Returns the longest prefix of the given list where all elements satisfy the predicate.\n\n ```aiken\n list.take_while([1, 2, 3], fn(x) { x &gt; 2 }) == []\n list.take_while([1, 2, 3], fn(x) { x &lt; 2 }) == [1]\n ```","url":"aiken/list.html#take_while"},{"doc":"aiken/list","title":"unique","content":"unique(self: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Removes duplicate elements from a list.\n\n ```aiken\n list.unique([1, 2, 3, 1]) == [1, 2, 3]\n ```","url":"aiken/list.html#unique"},{"doc":"aiken/list","title":"unzip","content":"unzip(self: List&lt;(a, b)&gt;) -&gt; (List&lt;a&gt;, List&lt;b&gt;)\n Decompose a list of tuples into a tuple of lists.\n\n ```\n list.unzip([(1, &quot;a&quot;), (2, &quot;b&quot;)]) == ([1, 2], [&quot;a&quot;, &quot;b&quot;])\n ```","url":"aiken/list.html#unzip"},{"doc":"aiken/list","title":"zip","content":"zip(self: List&lt;a&gt;, bs: List&lt;b&gt;) -&gt; List&lt;(a, b)&gt;\n Combine two lists together.\n\n Note: if one list is longer, the extra elements are dropped.\n\n ```aiken\n list.zip([1, 2], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) == [(1, &quot;a&quot;), (2, &quot;b&quot;)]\n ```","url":"aiken/list.html#zip"},{"doc":"aiken/list","title":"aiken/list","content":"","url":"aiken/list.html"},{"doc":"aiken/bytearray","title":"compare","content":"compare(left: ByteArray, right: ByteArray) -&gt; Ordering\n Compare two bytearrays lexicographically.\n\n ```aiken\n bytearray.compare(#00, #FF) == Less\n bytearray.compare(#42, #42) == Equal\n bytearray.compare(#FF, #00) == Greater\n ```","url":"aiken/bytearray.html#compare"},{"doc":"aiken/bytearray","title":"concat","content":"concat(left: ByteArray, right: ByteArray) -&gt; ByteArray\n Combine two `ByteArray` together.\n\n ```aiken\n bytearray.concat(left: #[1, 2, 3], right: #[4, 5, 6]) == #[1, 2, 3, 4, 5, 6]\n ```","url":"aiken/bytearray.html#concat"},{"doc":"aiken/bytearray","title":"drop","content":"drop(self: ByteArray, n: Int) -&gt; ByteArray\n Returns the suffix of a `ByteArray` after `n` elements.\n\n ```aiken\n bytearray.drop(#[1, 2, 3], n: 2) == #[3]\n ```","url":"aiken/bytearray.html#drop"},{"doc":"aiken/bytearray","title":"from_string","content":"from_string(str: String) -&gt; ByteArray\n Convert a `String` into a `ByteArray`.\n\n ```aiken\n bytearray.from_string(&quot;ABC&quot;) == #414243\n ```","url":"aiken/bytearray.html#from_string"},{"doc":"aiken/bytearray","title":"is_empty","content":"is_empty(self: ByteArray) -&gt; Bool\n Returns `True` when the given `ByteArray` is empty.\n\n ```aiken\n bytearray.is_empty(#&quot;&quot;) == True\n bytearray.is_empty(#&quot;00ff&quot;) == False\n ```","url":"aiken/bytearray.html#is_empty"},{"doc":"aiken/bytearray","title":"length","content":"length(self: ByteArray) -&gt; Int\n Returns the number of bytes in a `ByteArray`.\n\n ```aiken\n bytearray.length(#[1, 2, 3]) == 3\n ```","url":"aiken/bytearray.html#length"},{"doc":"aiken/bytearray","title":"push","content":"push(self: ByteArray, byte: Int) -&gt; ByteArray\n Add a byte element in front of a `ByteArray`. When the given byte is\n greater than 255, it wraps-around. So 256 is mapped to 0, 257 to 1, and so\n forth.\n\n ```aiken\n bytearray.push(#&quot;&quot;, 0) == #&quot;00&quot;\n bytearray.push(#&quot;0203&quot;, 1) == #&quot;010203&quot;\n bytearray.push(#&quot;0203&quot;, 257) == #&quot;010203&quot;\n ```","url":"aiken/bytearray.html#push"},{"doc":"aiken/bytearray","title":"slice","content":"slice(self: ByteArray, start: Int, end: Int) -&gt; ByteArray\n Extract a `ByteArray` as a slice of another `ByteArray`.\n\n Indexes are 0-based and inclusive.\n\n ```aiken\n bytearray.slice(#[0, 1, 2, 3, 4, 5, 6], start: 1, end: 3) == #[1, 2, 3]\n ```","url":"aiken/bytearray.html#slice"},{"doc":"aiken/bytearray","title":"take","content":"take(self: ByteArray, n: Int) -&gt; ByteArray\n Returns the n-length prefix of a `ByteArray`.\n\n ```aiken\n bytearray.take(#[1, 2, 3], n: 2) == #[1, 2]\n ```","url":"aiken/bytearray.html#take"},{"doc":"aiken/bytearray","title":"to_string","content":"to_string(self: ByteArray) -&gt; String\n Convert a `ByteArray` into a `String`.\n\n ```aiken\n bytearray.to_string(#&quot;414243&quot;) == &quot;ABC&quot;\n ```","url":"aiken/bytearray.html#to_string"},{"doc":"aiken/bytearray","title":"aiken/bytearray","content":"","url":"aiken/bytearray.html"},{"doc":"aiken/string","title":"concat","content":"concat(left: String, right: String) -&gt; String\n Combine two `String` together.\n\n ```aiken\n string.concat(left: &quot;Hello&quot;, right: &quot;, World!&quot;)\n // &quot;Hello, World!&quot;\n ```","url":"aiken/string.html#concat"},{"doc":"aiken/string","title":"from_bytearray","content":"from_bytearray(bytes: ByteArray) -&gt; String\n Convert a `ByteArray` into a `String`","url":"aiken/string.html#from_bytearray"},{"doc":"aiken/string","title":"from_int","content":"from_int(n: Int) -&gt; String\n Convert an `Int` to its `String` representation.\n\n ```aiken\n use builtin/string\n\n string.from_int(42)\n // &quot;42&quot;\n ```","url":"aiken/string.html#from_int"},{"doc":"aiken/string","title":"join","content":"join(list: List&lt;String&gt;, delimiter: String) -&gt; String\n Join a list of strings, separated by a given _delimiter_.\n\n ```aiken\n use aiken/string\n\n string.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;,&quot;)\n // &quot;a,b,c&quot;\n ```","url":"aiken/string.html#join"},{"doc":"aiken/string","title":"to_bytearray","content":"to_bytearray(self: String) -&gt; ByteArray\n Convert a `String` into a `ByteArray`","url":"aiken/string.html#to_bytearray"},{"doc":"aiken/string","title":"aiken/string","content":"","url":"aiken/string.html"},{"doc":"aiken/option","title":"and_then","content":"and_then(self: Option&lt;a&gt;, then: fn(a) -&gt; Option&lt;result&gt;) -&gt; Option&lt;result&gt;\n Chain together many computations that may fail.","url":"aiken/option.html#and_then"},{"doc":"aiken/option","title":"choice","content":"choice(self: List&lt;Option&lt;a&gt;&gt;) -&gt; Option&lt;a&gt;\n Picks the first element which is not None. If there&#39;s no such element, return None.\n\n ## Examples\n\n ```aiken\n choice([]) = None\n\n choice([Some(14), Some(42)]) = Some(14)\n\n choice([None, Some(42)]) = Some(42)\n\n choice([None, None]) = None\n ```","url":"aiken/option.html#choice"},{"doc":"aiken/option","title":"flatten","content":"flatten(opt: Option&lt;Option&lt;a&gt;&gt;) -&gt; Option&lt;a&gt;\n Converts from `Option&lt;Option&lt;a&gt;&gt;` to `Option&lt;a&gt;`.\n\n ## Examples\n\n Basic usage:\n\n ```aiken\n use aiken/option\n\n let x: Option&lt;Option&lt;Int&gt;&gt; = Some(Some(6))\n Some(6) == flatten(x)\n\n let x: Option&lt;Option&lt;Int&gt;&gt; = Some(None)\n None == flatten(x)\n\n let x: Option&lt;Option&lt;Int&gt;&gt; = None\n None == flatten(x)\n ```\n\n Flattening only removes one level of nesting at a time:\n\n ```aiken\n let x: Option&lt;Option&lt;Option&lt;Int&gt;&gt;&gt; = Some(Some(Some(6)))\n Some(Some(6)) == flatten(x)\n Some(6) == { x |&gt; flatten |&gt; flatten }\n ```","url":"aiken/option.html#flatten"},{"doc":"aiken/option","title":"is_none","content":"is_none(self: Option&lt;a&gt;) -&gt; Bool\n Asserts whether an option is `None`.","url":"aiken/option.html#is_none"},{"doc":"aiken/option","title":"is_some","content":"is_some(self: Option&lt;a&gt;) -&gt; Bool\n Asserts whether an option is `Some`, irrespective of the value it contains.","url":"aiken/option.html#is_some"},{"doc":"aiken/option","title":"map","content":"map(self: Option&lt;a&gt;, with: fn(a) -&gt; result) -&gt; Option&lt;result&gt;\n Apply a function to the inner value of an Option","url":"aiken/option.html#map"},{"doc":"aiken/option","title":"map2","content":"map2(\n  opt_a: Option&lt;a&gt;,\n  opt_b: Option&lt;b&gt;,\n  with: fn(a, b) -&gt; result,\n) -&gt; Option&lt;result&gt;\n Combine two &#39;Option&#39; together.","url":"aiken/option.html#map2"},{"doc":"aiken/option","title":"map3","content":"map3(\n  opt_a: Option&lt;a&gt;,\n  opt_b: Option&lt;b&gt;,\n  opt_c: Option&lt;c&gt;,\n  with: fn(a, b, c) -&gt; result,\n) -&gt; Option&lt;result&gt;\n","url":"aiken/option.html#map3"},{"doc":"aiken/option","title":"or_else","content":"or_else(self: Option&lt;a&gt;, default: a) -&gt; a\n Provide a default value, turning an optional value into a normal value.","url":"aiken/option.html#or_else"},{"doc":"aiken/option","title":"aiken/option","content":"","url":"aiken/option.html"},{"doc":"aiken/transaction/certificate","title":"Certificate","content":"Certificate {\n  CredentialRegistration { delegator: StakeCredential }\n  CredentialDeregistration { delegator: StakeCredential }\n  CredentialDelegation { delegator: StakeCredential, delegatee: PoolId }\n  PoolRegistration { pool_id: PoolId, vrf: Hash&lt;Blake2b_224, VerificationKey&gt; }\n  PoolDeregistration { pool_id: PoolId, epoch: Int }\n  Governance\n  TreasuryMovement\n}\n An on-chain certificate attesting of some operation. Publishing\n certificates / triggers different kind of rules; most of the time,\n they require signatures from / specific keys.\nCredentialRegistration { delegator: StakeCredential }\n\nCredentialDeregistration { delegator: StakeCredential }\n\nCredentialDelegation { delegator: StakeCredential, delegatee: PoolId }\n\nPoolRegistration { pool_id: PoolId, vrf: Hash&lt;Blake2b_224, VerificationKey&gt; }\n\nPoolDeregistration { pool_id: PoolId, epoch: Int }\n\nGovernance\n\nTreasuryMovement\n","url":"aiken/transaction/certificate.html#Certificate"},{"doc":"aiken/transaction/certificate","title":"aiken/transaction/certificate","content":"","url":"aiken/transaction/certificate.html"},{"doc":"utils","title":"get_input","content":"get_input(ctx: ScriptContext, address: Address) -&gt; Option&lt;Input&gt;\n","url":"utils.html#get_input"},{"doc":"utils","title":"get_input2","content":"get_input2(ctx: ScriptContext, address: Address) -&gt; Option&lt;Input&gt;\n","url":"utils.html#get_input2"},{"doc":"utils","title":"get_output","content":"get_output(ctx: ScriptContext, address: Address) -&gt; Option&lt;Output&gt;\n","url":"utils.html#get_output"},{"doc":"utils","title":"get_output2","content":"get_output2(ctx: ScriptContext, address: Address) -&gt; Option&lt;Output&gt;\n","url":"utils.html#get_output2"},{"doc":"utils","title":"get_validator_address","content":"get_validator_address(\n  ctx: ScriptContext,\n  output_reference: OutputReference,\n) -&gt; Address\n","url":"utils.html#get_validator_address"},{"doc":"utils","title":"own_validator_script_address_hash","content":"own_validator_script_address_hash(\n  inputs: List&lt;Input&gt;,\n  output_reference: OutputReference,\n) -&gt; Option&lt;ValidatorHash&gt;\n","url":"utils.html#own_validator_script_address_hash"},{"doc":"utils","title":"scripthash_address","content":"scripthash_address(scripthash: ByteArray) -&gt; Address\n","url":"utils.html#scripthash_address"},{"doc":"utils","title":"ValidatorHash","content":"ValidatorHash = Hash&lt;Blake2b_224, Script&gt;\n\n","url":"utils.html#ValidatorHash"},{"doc":"utils","title":"utils","content":"","url":"utils.html"},{"doc":"aada_nft","title":"MintingRedeemerType","content":"MintingRedeemerType {\n  utxo_ref: TransactionId,\n  utxo_id: Int,\n}\n\nMintingRedeemerType { utxo_ref: TransactionId, utxo_id: Int }\n","url":"aada_nft.html#MintingRedeemerType"},{"doc":"aada_nft","title":"RedeemerType","content":"RedeemerType {\n  MintR(MintingRedeemerType)\n  BurnR(AssetName)\n}\n\nMintR(MintingRedeemerType)\n\nBurnR(AssetName)\n","url":"aada_nft.html#RedeemerType"},{"doc":"aada_nft","title":"aada_nft","content":"","url":"aada_nft.html"},{"doc":"interest","title":"CurrencySymbol","content":"CurrencySymbol {\n  policy_id: PolicyId,\n  asset_name: AssetName,\n}\n\nCurrencySymbol { policy_id: PolicyId, asset_name: AssetName }\n","url":"interest.html#CurrencySymbol"},{"doc":"interest","title":"InterestDatum","content":"InterestDatum {\n  lender_tn: AssetName,\n}\n\nInterestDatum { lender_tn: AssetName }\n","url":"interest.html#InterestDatum"},{"doc":"interest","title":"interest","content":"","url":"interest.html"},{"doc":"aiken/transaction/value","title":"add","content":"add(left: Value, right: Value) -&gt; Value\n Combine two `Value` together.","url":"aiken/transaction/value.html#add"},{"doc":"aiken/transaction/value","title":"flatten","content":"flatten(self: Value) -&gt; List&lt;(PolicyId, AssetName, Int)&gt;\n Flatten a value as list of 3-tuple (PolicyId, AssetName, Quantity).\n\n Handy to manipulate values as uniform lists.","url":"aiken/transaction/value.html#flatten"},{"doc":"aiken/transaction/value","title":"from_asset","content":"from_asset(policy_id: PolicyId, asset_name: AssetName, quantity: Int) -&gt; Value\n Construct a `Value` from an asset identifier (i.e. `PolicyId` + `AssetName`)\n and a given quantity.","url":"aiken/transaction/value.html#from_asset"},{"doc":"aiken/transaction/value","title":"from_lovelace","content":"from_lovelace(quantity: Int) -&gt; Value\n Construct a `Value` from a lovelace quantity.\n\n Friendly reminder: 1 Ada = 1.000.000 Lovelace","url":"aiken/transaction/value.html#from_lovelace"},{"doc":"aiken/transaction/value","title":"lovelace_of","content":"lovelace_of(self: Value) -&gt; Int\n A specialized version of `quantity_of` for the Ada currency.","url":"aiken/transaction/value.html#lovelace_of"},{"doc":"aiken/transaction/value","title":"negate","content":"negate(self: Value) -&gt; Value\n Negates quantities of all tokens (including Ada) in that `Value`.\n\n ```\n use aiken/transaction/value\n\n v1\n |&gt; value.negate\n |&gt; value.add\n |&gt; value.is_zero\n // True\n ```","url":"aiken/transaction/value.html#negate"},{"doc":"aiken/transaction/value","title":"policies","content":"policies(self: Value) -&gt; List&lt;PolicyId&gt;\n A list of all token policies in that Value with non-zero tokens.","url":"aiken/transaction/value.html#policies"},{"doc":"aiken/transaction/value","title":"quantity_of","content":"quantity_of(self: Value, policy_id: PolicyId, asset_name: AssetName) -&gt; Int\n Extract the quantity of a given asset.","url":"aiken/transaction/value.html#quantity_of"},{"doc":"aiken/transaction/value","title":"tokens","content":"tokens(self: Value, policy_id: PolicyId) -&gt; Dict&lt;AssetName, Int&gt;\n Get all tokens associated with a given policy.","url":"aiken/transaction/value.html#tokens"},{"doc":"aiken/transaction/value","title":"without_lovelace","content":"without_lovelace(self: Value) -&gt; Value\n Get a `Value` excluding Ada.","url":"aiken/transaction/value.html#without_lovelace"},{"doc":"aiken/transaction/value","title":"zero","content":"zero() -&gt; Value\n Construct an empty `Value` with nothing in it.","url":"aiken/transaction/value.html#zero"},{"doc":"aiken/transaction/value","title":"AssetName","content":"AssetName = ByteArray\n A type-alias for &#39;AssetName`, which are free-form byte-arrays between\n 0 and 32 bytes.\n","url":"aiken/transaction/value.html#AssetName"},{"doc":"aiken/transaction/value","title":"PolicyId","content":"PolicyId = Hash&lt;Blake2b_224, Script&gt;\n A type-alias for a `PolicyId`. A `PolicyId` is always 28-byte long\n","url":"aiken/transaction/value.html#PolicyId"},{"doc":"aiken/transaction/value","title":"Value","content":"Value\n A multi-asset output `Value`. Contains tokens indexed by [PolicyId](#PolicyId) and [AssetName](#AssetName).\n\n This type maintain some invariants by construction; in particular, a `Value` will never contain a\n zero quantity of a particular token.\n","url":"aiken/transaction/value.html#Value"},{"doc":"aiken/transaction/value","title":"ada_asset_name","content":"ada_asset_name: ByteArray = #&quot;&quot;\n Ada, the native currency, isn&#39;t associated with any `AssetName` (it&#39;s not\n possible to mint Ada!).\n\n By convention, it is an empty `ByteArray`.","url":"aiken/transaction/value.html#ada_asset_name"},{"doc":"aiken/transaction/value","title":"ada_policy_id","content":"ada_policy_id: ByteArray = #&quot;&quot;\n Ada, the native currency, isn&#39;t associated with any `PolicyId` (it&#39;s not\n possible to mint Ada!).\n\n By convention, it is an empty `ByteArray`.","url":"aiken/transaction/value.html#ada_policy_id"},{"doc":"aiken/transaction/value","title":"aiken/transaction/value","content":"","url":"aiken/transaction/value.html"},{"doc":"aiken/int","title":"compare","content":"compare(left: Int, right: Int) -&gt; Ordering\n Compare two integers.\n\n ```aiken\n compare(14, 42) == Less\n compare(14, 14) == Equal\n compare(42, 14) == Greater\n ```","url":"aiken/int.html#compare"},{"doc":"aiken/int","title":"aiken/int","content":"","url":"aiken/int.html"},{"doc":"aiken/transaction/credential","title":"from_script","content":"from_script(script: Hash&lt;Blake2b_224, Script&gt;) -&gt; Address\n Smart-constructor for an `Address` from a script hash. The address has no delegation rights whatsoever.","url":"aiken/transaction/credential.html#from_script"},{"doc":"aiken/transaction/credential","title":"from_verification_key","content":"from_verification_key(vk: Hash&lt;Blake2b_224, VerificationKey&gt;) -&gt; Address\n Smart-constructor for an `Address` from a verification key hash. The address has no delegation rights whatsoever.","url":"aiken/transaction/credential.html#from_verification_key"},{"doc":"aiken/transaction/credential","title":"verify_signature","content":"verify_signature(key: VerificationKey, msg: ByteArray, sig: Signature) -&gt; Bool\n Verify an Ed25519 signature using the given verification key.\n Returns `True` when the signature is valid.","url":"aiken/transaction/credential.html#verify_signature"},{"doc":"aiken/transaction/credential","title":"Address","content":"Address {\n  payment_credential: PaymentCredential,\n  stake_credential: Option&lt;StakeCredential&gt;,\n}\n A Cardano `Address` typically holding one or two credential references.\n\n Note that legacy bootstrap addresses (a.k.a. &#39;Byron addresses&#39;) are\n completely excluded from Plutus contexts. Thus, from an on-chain\n perspective only exists addresses of type 00, 01, ..., 07 as detailed\n in [CIP-0019 :: Shelley Addresses](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#shelley-addresses).\nAddress {\n  payment_credential: PaymentCredential,\n  stake_credential: Option&lt;StakeCredential&gt;,\n}\n","url":"aiken/transaction/credential.html#Address"},{"doc":"aiken/transaction/credential","title":"Credential","content":"Credential {\n  VerificationKeyCredential(Hash&lt;Blake2b_224, VerificationKey&gt;)\n  ScriptCredential(Hash&lt;Blake2b_224, Script&gt;)\n}\n A general structure for representing an on-chain `Credential`.\n\n Credentials are always one of two kinds: a direct public/private key\n pair, or a script (native or Plutus).\nVerificationKeyCredential(Hash&lt;Blake2b_224, VerificationKey&gt;)\n\nScriptCredential(Hash&lt;Blake2b_224, Script&gt;)\n","url":"aiken/transaction/credential.html#Credential"},{"doc":"aiken/transaction/credential","title":"PaymentCredential","content":"PaymentCredential = Credential\n A &#39;PaymentCredential&#39; represents the spending conditions associated with\n some output. Hence,\n\n - a `VerificationKeyCredential` captures an output locked by a public/private key pair;\n - and a `ScriptCredential` captures an output locked by a native or Plutus script.\n\n","url":"aiken/transaction/credential.html#PaymentCredential"},{"doc":"aiken/transaction/credential","title":"PoolId","content":"PoolId = Hash&lt;Blake2b_224, VerificationKey&gt;\n A unique stake pool identifier, as a hash of its owner verification key.\n","url":"aiken/transaction/credential.html#PoolId"},{"doc":"aiken/transaction/credential","title":"Referenced","content":"Referenced&lt;a&gt; {\n  Inline(a)\n  Pointer { slot_number: Int, transaction_index: Int, certificate_index: Int }\n}\n Represent a type of object that can be represented either inline (by hash)\n or via a reference (i.e. a pointer to an on-chain location).\n\n This is mainly use for capturing pointers to a stake credential\n registration certificate in the case of so-called pointer addresses.\nInline(a)\n\nPointer { slot_number: Int, transaction_index: Int, certificate_index: Int }\n","url":"aiken/transaction/credential.html#Referenced"},{"doc":"aiken/transaction/credential","title":"Script","content":"Script = ByteArray\n\n","url":"aiken/transaction/credential.html#Script"},{"doc":"aiken/transaction/credential","title":"Signature","content":"Signature = ByteArray\n\n","url":"aiken/transaction/credential.html#Signature"},{"doc":"aiken/transaction/credential","title":"StakeCredential","content":"StakeCredential = Referenced&lt;Credential&gt;\n A `StakeCredential` represents the delegation and rewards withdrawal conditions\n associated with some stake address / account.\n\n A `StakeCredential` is either provided inline, or, by reference using an\n on-chain pointer.\n\n Read more about pointers in [CIP-0019 :: Pointers](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#pointers).\n","url":"aiken/transaction/credential.html#StakeCredential"},{"doc":"aiken/transaction/credential","title":"VerificationKey","content":"VerificationKey = ByteArray\n\n","url":"aiken/transaction/credential.html#VerificationKey"},{"doc":"aiken/transaction/credential","title":"aiken/transaction/credential","content":"","url":"aiken/transaction/credential.html"},{"doc":"aiken/hash","title":"blake2b_256","content":"blake2b_256(bytes: ByteArray) -&gt; Hash&lt;Blake2b_256, a&gt;\n Compute the blake2b-256 hash digest of some data.","url":"aiken/hash.html#blake2b_256"},{"doc":"aiken/hash","title":"sha2_256","content":"sha2_256(bytes: ByteArray) -&gt; Hash&lt;Sha2_256, a&gt;\n Compute the sha2-256 hash digest of some data.","url":"aiken/hash.html#sha2_256"},{"doc":"aiken/hash","title":"sha3_256","content":"sha3_256(bytes: ByteArray) -&gt; Hash&lt;Sha3_256, a&gt;\n Compute the sha3-256 hash digest of some data.","url":"aiken/hash.html#sha3_256"},{"doc":"aiken/hash","title":"Blake2b_224","content":"Blake2b_224\n A blake2b-224 hash algorithm.\n\n Typically used for:\n\n - [`Credential`](../aiken/transaction/credential.html#Credential)\n - [`PolicyId`](../aiken/transaction/value.html#PolicyId)\n\n Note: there&#39;s no function to calculate blake2b-224 hash digests on-chain.\n","url":"aiken/hash.html#Blake2b_224"},{"doc":"aiken/hash","title":"Blake2b_256","content":"Blake2b_256\n A blake2b-256 hash algorithm.\n\n Typically used for:\n\n - [`TransactionId`](../aiken/transaction.html#TransactionId)\n\n","url":"aiken/hash.html#Blake2b_256"},{"doc":"aiken/hash","title":"Hash","content":"Hash&lt;alg, a&gt; = ByteArray\n A `Hash` is nothing more than a `ByteArray`, but it carries extra\n information for readability.\n","url":"aiken/hash.html#Hash"},{"doc":"aiken/hash","title":"Sha2_256","content":"Sha2_256\n A SHA2-256 hash algorithm.\n","url":"aiken/hash.html#Sha2_256"},{"doc":"aiken/hash","title":"Sha3_256","content":"Sha3_256\n A SHA3-256 hash algorithm.\n","url":"aiken/hash.html#Sha3_256"},{"doc":"aiken/hash","title":"aiken/hash","content":" This module defines `Hash`, a self-documenting type-alias with a\n phantom-type for readability.\n\n On-chain, any hash digest value is represented as a plain &#39;ByteArray&#39;.\n Though in practice, hashes come from different sources and have\n different semantics.\n\n Hence, while this type-alias doesn&#39;t provide any strong type-guarantees,\n it helps writing functions signatures with more meaningful types than mere\n &#39;ByteArray&#39;.\n\n Compare for example:\n\n ```aiken\n pub type Credential {\n   VerificationKeyCredential(ByteArray)\n   ScriptCredential(ByteArray)\n }\n ```\n\n with\n\n ```aiken\n pub type Credential {\n   VerificationKeyCredential(Hash&lt;Blake2b_224, VerificationKey&gt;)\n   ScriptCredential(Hash&lt;Blake2b_224, Script&gt;)\n }\n ```\n\n Both are strictly equivalent, but the second reads much better.","url":"aiken/hash.html"},{"doc":"aiken/transaction","title":"Datum","content":"Datum {\n  NoDatum\n  DatumHash(Hash&lt;Blake2b_256, Data&gt;)\n  InlineDatum(Data)\n}\n An output `Datum`.\nNoDatum\n\nDatumHash(Hash&lt;Blake2b_256, Data&gt;)\n A datum referenced by its hash digest.\nInlineDatum(Data)\n A datum completely inlined in the output.","url":"aiken/transaction.html#Datum"},{"doc":"aiken/transaction","title":"Input","content":"Input {\n  output_reference: OutputReference,\n  output: Output,\n}\n An `Input` made of an output reference and, the resolved value associated with that output.\nInput { output_reference: OutputReference, output: Output }\n","url":"aiken/transaction.html#Input"},{"doc":"aiken/transaction","title":"Output","content":"Output {\n  address: Address,\n  value: Value,\n  datum: Datum,\n  reference_script: Option&lt;Hash&lt;Blake2b_224, Script&gt;&gt;,\n}\n A transaction `Output`, with an address, a value and optional datums and script references.\nOutput {\n  address: Address,\n  value: Value,\n  datum: Datum,\n  reference_script: Option&lt;Hash&lt;Blake2b_224, Script&gt;&gt;,\n}\n","url":"aiken/transaction.html#Output"},{"doc":"aiken/transaction","title":"OutputReference","content":"OutputReference {\n  transaction_id: TransactionId,\n  output_index: Int,\n}\n An `OutputReference` is a unique reference to an output on-chain. The `output_index`\n corresponds to the position in the output list of the transaction (identified by its id)\n that produced that output\nOutputReference { transaction_id: TransactionId, output_index: Int }\n","url":"aiken/transaction.html#OutputReference"},{"doc":"aiken/transaction","title":"Redeemer","content":"Redeemer = Data\n A type-alias for Redeemers, passed to scripts for validation. The `Data` is\n opaque because it is user-defined and it is the script&#39;s responsability to\n parse it into its expected form.\n","url":"aiken/transaction.html#Redeemer"},{"doc":"aiken/transaction","title":"ScriptContext","content":"ScriptContext {\n  transaction: Transaction,\n  purpose: ScriptPurpose,\n}\n A context given to a script by the Cardano ledger when being executed.\n\n The context contains information about the entire transaction that contains\n the script. The transaction may also contain other scripts; to distinguish\n between multiple scripts, the `ScriptContext` also contains a `purpose`\n which indicates which script (or, for what purpose) of the transaction is\n being executed.\nScriptContext { transaction: Transaction, purpose: ScriptPurpose }\n","url":"aiken/transaction.html#ScriptContext"},{"doc":"aiken/transaction","title":"ScriptPurpose","content":"ScriptPurpose {\n  Mint(PolicyId)\n  Spend(OutputReference)\n  WithdrawFrom(StakeCredential)\n  Publish(Certificate)\n}\n Characterizes the kind of script being executed.\nMint(PolicyId)\n For scripts executed as minting/burning policies, to insert\n or remove assets from circulation. It&#39;s parameterized by the identifier\n of the associated policy.\nSpend(OutputReference)\n For scripts that are used as payment credentials for addresses in\n transaction outputs. They govern the rule by which the output they\n reference can be spent.\nWithdrawFrom(StakeCredential)\n For scripts that validate reward withdrawals from a reward account.\n\n The argument identifies the target reward account.\nPublish(Certificate)\n Needed when delegating to a pool using stake credentials defined as a\n Plutus script. This purpose is also triggered when de-registering such\n stake credentials.\n\n It embeds the certificate that&#39;s being validated.","url":"aiken/transaction.html#ScriptPurpose"},{"doc":"aiken/transaction","title":"Transaction","content":"Transaction {\n  inputs: List&lt;Input&gt;,\n  reference_inputs: List&lt;Input&gt;,\n  outputs: List&lt;Output&gt;,\n  fee: Value,\n  mint: Value,\n  certificates: List&lt;Certificate&gt;,\n  withdrawals: Dict&lt;StakeCredential, Int&gt;,\n  validity_range: ValidityRange,\n  extra_signatories: List&lt;Hash&lt;Blake2b_224, VerificationKey&gt;&gt;,\n  redeemers: Dict&lt;ScriptPurpose, Redeemer&gt;,\n  datums: Dict&lt;Hash&lt;Blake2b_256, Data&gt;, Data&gt;,\n  id: TransactionId,\n}\n A Cardano `Transaction`, as seen by Plutus scripts.\n\n Note that this is a representation of a transaction, and not the 1:1\n translation of the transaction as seen by the ledger. In particular,\n Plutus scripts can&#39;t see inputs locked by bootstrap addresses, outputs\n to bootstrap addresses or just transaction metadata.\nTransaction {\n  inputs: List&lt;Input&gt;,\n  reference_inputs: List&lt;Input&gt;,\n  outputs: List&lt;Output&gt;,\n  fee: Value,\n  mint: Value,\n  certificates: List&lt;Certificate&gt;,\n  withdrawals: Dict&lt;StakeCredential, Int&gt;,\n  validity_range: ValidityRange,\n  extra_signatories: List&lt;Hash&lt;Blake2b_224, VerificationKey&gt;&gt;,\n  redeemers: Dict&lt;ScriptPurpose, Redeemer&gt;,\n  datums: Dict&lt;Hash&lt;Blake2b_256, Data&gt;, Data&gt;,\n  id: TransactionId,\n}\n","url":"aiken/transaction.html#Transaction"},{"doc":"aiken/transaction","title":"TransactionId","content":"TransactionId {\n  hash: Hash&lt;Blake2b_256, Transaction&gt;,\n}\n A unique transaction identifier, as the hash of a transaction body. Note that the transaction id\n isn&#39;t a direct hash of the `Transaction` as visible on-chain. Rather, they correspond to hash\n digests of transaction body as they are serialized on the network.\nTransactionId { hash: Hash&lt;Blake2b_256, Transaction&gt; }\n","url":"aiken/transaction.html#TransactionId"},{"doc":"aiken/transaction","title":"ValidityRange","content":"ValidityRange = Interval&lt;Int&gt;\n An interval of POSIX time, measured in number milliseconds since 1970-01-01T00:00:00Z.\n","url":"aiken/transaction.html#ValidityRange"},{"doc":"aiken/transaction","title":"aiken/transaction","content":"","url":"aiken/transaction.html"},{"doc":"v2_order","title":"correct_details_saved","content":"correct_details_saved(\n  ctx: ScriptContext,\n  lender_tn: AssetName,\n  script_address: Address,\n  lower_validity_range: Int,\n) -&gt; Bool\n","url":"v2_order.html#correct_details_saved"},{"doc":"v2_order","title":"get_lower_bound","content":"get_lower_bound(range: ValidityRange) -&gt; Int\n","url":"v2_order.html#get_lower_bound"},{"doc":"v2_order","title":"paid_to_address","content":"paid_to_address(\n  tx_output: List&lt;Output&gt;,\n  address: Address,\n  policy_id: PolicyId,\n  token_name: AssetName,\n  amount: Int,\n) -&gt; Bool\n","url":"v2_order.html#paid_to_address"},{"doc":"v2_order","title":"scripthash_address","content":"scripthash_address(scripthash: ByteArray) -&gt; Address\n","url":"v2_order.html#scripthash_address"},{"doc":"v2_order","title":"validate_pool_borrow","content":"validate_pool_borrow(\n  ctx: ScriptContext,\n  output_reference: OutputReference,\n  datum: PoolDatum,\n  redeemer: PoolBorrowRedeemer,\n) -&gt; Bool\n","url":"v2_order.html#validate_pool_borrow"},{"doc":"v2_order","title":"validate_pool_deposit","content":"validate_pool_deposit(\n  ctx: ScriptContext,\n  output_reference: OutputReference,\n  datum: PoolDatum,\n  redeemer: PoolDepositRedeemer,\n) -&gt; Bool\n","url":"v2_order.html#validate_pool_deposit"},{"doc":"v2_order","title":"CurrencySymbol","content":"CurrencySymbol {\n  policy_id: PolicyId,\n  asset_name: AssetName,\n}\n\nCurrencySymbol { policy_id: PolicyId, asset_name: AssetName }\n","url":"v2_order.html#CurrencySymbol"},{"doc":"v2_order","title":"DepositRedeemer","content":"DepositRedeemer {\n  lender_token_name: AssetName,\n  lower_validity_range: Int,\n}\n\nDepositRedeemer { lender_token_name: AssetName, lower_validity_range: Int }\n","url":"v2_order.html#DepositRedeemer"},{"doc":"v2_order","title":"LenderDetailsDatum","content":"LenderDetailsDatum {\n  lender_tn: AssetName,\n  deposit_time: Int,\n}\n\nLenderDetailsDatum { lender_tn: AssetName, deposit_time: Int }\n","url":"v2_order.html#LenderDetailsDatum"},{"doc":"v2_order","title":"OrderDatum","content":"OrderDatum {\n  depositor_address: Address,\n}\n\nOrderDatum { depositor_address: Address }\n","url":"v2_order.html#OrderDatum"},{"doc":"v2_order","title":"OrderRedeemerType","content":"OrderRedeemerType {\n  Cancel(Int)\n  Deposit(DepositRedeemer)\n}\n\nCancel(Int)\n\nDeposit(DepositRedeemer)\n","url":"v2_order.html#OrderRedeemerType"},{"doc":"v2_order","title":"PoolBorrowRedeemer","content":"PoolBorrowRedeemer {\n  input_cs: CurrencySymbol,\n  input_amount: Int,\n}\n\nPoolBorrowRedeemer { input_cs: CurrencySymbol, input_amount: Int }\n","url":"v2_order.html#PoolBorrowRedeemer"},{"doc":"v2_order","title":"PoolDatum","content":"PoolDatum {\n  currency_symbol: CurrencySymbol,\n  balance: Int,\n  lent_out: Int,\n}\n\nPoolDatum { currency_symbol: CurrencySymbol, balance: Int, lent_out: Int }\n","url":"v2_order.html#PoolDatum"},{"doc":"v2_order","title":"PoolDepositRedeemer","content":"PoolDepositRedeemer {\n  input_cs: CurrencySymbol,\n  input_amount: Int,\n}\n\nPoolDepositRedeemer { input_cs: CurrencySymbol, input_amount: Int }\n","url":"v2_order.html#PoolDepositRedeemer"},{"doc":"v2_order","title":"PoolRedeemerType","content":"PoolRedeemerType {\n  PoolWithdraw(Int)\n  PoolDeposit(PoolDepositRedeemer)\n  PoolBorrow(PoolBorrowRedeemer)\n}\n\nPoolWithdraw(Int)\n\nPoolDeposit(PoolDepositRedeemer)\n\nPoolBorrow(PoolBorrowRedeemer)\n","url":"v2_order.html#PoolRedeemerType"},{"doc":"v2_order","title":"v2_order","content":" Allow to consume from validator in 2 ocasions:\n 1. Lender is canceling the request (signed by lender)\n 2. Batched correctly and lender receives what expected","url":"v2_order.html"},{"doc":"request","title":"keyhash_address","content":"keyhash_address(keyhash: ByteArray) -&gt; Address\n","url":"request.html#keyhash_address"},{"doc":"request","title":"paid_borrower","content":"paid_borrower(\n  tx_output: List&lt;Output&gt;,\n  borrower_address: Address,\n  loan_asset: CurrencySymbol,\n  loan_amount: Int,\n) -&gt; Bool\n","url":"request.html#paid_borrower"},{"doc":"request","title":"scripthash_address","content":"scripthash_address(scripthash: ByteArray) -&gt; Address\n","url":"request.html#scripthash_address"},{"doc":"request","title":"validate_collateral_output","content":"validate_collateral_output(\n  ctx: ScriptContext,\n  expected_datum: RequestDatum,\n  datum: RequestDatum,\n  contract_address: Address,\n) -&gt; Bool\n","url":"request.html#validate_collateral_output"},{"doc":"request","title":"CurrencySymbol","content":"CurrencySymbol {\n  policy_id: PolicyId,\n  asset_name: AssetName,\n}\n\nCurrencySymbol { policy_id: PolicyId, asset_name: AssetName }\n","url":"request.html#CurrencySymbol"},{"doc":"request","title":"RequestDatum","content":"RequestDatum {\n  borrower_tn: AssetName,\n  borrower_address: Address,\n  loan_asset: CurrencySymbol,\n  loan_amount: Int,\n  interest_asset: CurrencySymbol,\n  interest_amount: Int,\n  collateral_asset: CurrencySymbol,\n  collateral_amount: Int,\n  loan_duration: Int,\n  liquidate_nft: PolicyId,\n  collateral_factor: Int,\n  liquidation_commision: Int,\n  request_expiration_time: Int,\n  lender_tn: AssetName,\n  lend_date: Int,\n}\n\nRequestDatum {\n  borrower_tn: AssetName,\n  borrower_address: Address,\n  loan_asset: CurrencySymbol,\n  loan_amount: Int,\n  interest_asset: CurrencySymbol,\n  interest_amount: Int,\n  collateral_asset: CurrencySymbol,\n  collateral_amount: Int,\n  loan_duration: Int,\n  liquidate_nft: PolicyId,\n  collateral_factor: Int,\n  liquidation_commision: Int,\n  request_expiration_time: Int,\n  lender_tn: AssetName,\n  lend_date: Int,\n}\n","url":"request.html#RequestDatum"},{"doc":"request","title":"request","content":"","url":"request.html"},{"doc":"aiken/dict","title":"delete","content":"delete(self: Dict&lt;key, value&gt;, key: key) -&gt; Dict&lt;key, value&gt;\n Remove a key-value pair from the dictionnary. If the key is not found, no changes are made.\n\n ```aiken\n dict.new()\n |&gt; dict.insert(key: 14, value: 42, int.compare)\n |&gt; dict.delete(key: 14)\n |&gt; dict.get(14)\n // None\n ```","url":"aiken/dict.html#delete"},{"doc":"aiken/dict","title":"filter","content":"filter(self: Dict&lt;key, value&gt;, with: fn(key, value) -&gt; Bool) -&gt; Dict&lt;key, value&gt;\n Keep only the key-value pairs that pass the given predicate.","url":"aiken/dict.html#filter"},{"doc":"aiken/dict","title":"find","content":"find(self: Dict&lt;key, value&gt;, value: value) -&gt; Option&lt;key&gt;\n Finds a value in the dictionnary, and returns the first key found to have that value.\n\n ```aiken\n dict.new()\n |&gt; dict.insert(key: foo, value: 42, bytearray.compare)\n |&gt; dict.insert(key: bar, value: 14, bytearray.compare)\n |&gt; dict.find(42)\n // Some(foo)\n ```","url":"aiken/dict.html#find"},{"doc":"aiken/dict","title":"fold","content":"fold(\n  self: Dict&lt;key, value&gt;,\n  with: fn(key, value, result) -&gt; result,\n  zero: result,\n) -&gt; result\n Fold over the key-value pairs in a dictionnary.","url":"aiken/dict.html#fold"},{"doc":"aiken/dict","title":"from_list","content":"from_list(\n  self: List&lt;(key, value)&gt;,\n  compare: fn(key, key) -&gt; Ordering,\n) -&gt; Dict&lt;key, value&gt;\n Construct a dictionnary from a list of key-value pairs. Note that when a key is present\n multiple times, the first occurence prevails.","url":"aiken/dict.html#from_list"},{"doc":"aiken/dict","title":"get","content":"get(self: Dict&lt;key, value&gt;, key: key) -&gt; Option&lt;value&gt;\n Get a value in the dict by its key.\n\n ```aiken\n dict.new()\n |&gt; dict.insert(key: foo, value: &quot;Aiken&quot;, bytearray.compare)\n |&gt; dict.get(key: foo)\n // Some(&quot;Aiken&quot;)\n ```","url":"aiken/dict.html#get"},{"doc":"aiken/dict","title":"has_key","content":"has_key(self: Dict&lt;key, value&gt;, key: key) -&gt; Bool\n Check if a key exists in the dictionnary.\n\n ```aiken\n dict.new()\n |&gt; dict.insert(key: foo, value: &quot;Aiken&quot;, bytearray.compare)\n |&gt; dict.has_key(foo)\n // True\n ```","url":"aiken/dict.html#has_key"},{"doc":"aiken/dict","title":"insert","content":"insert(\n  self: Dict&lt;key, value&gt;,\n  key: key,\n  value: value,\n  compare: fn(key, key) -&gt; Ordering,\n) -&gt; Dict&lt;key, value&gt;\n Insert a value in the dictionnary at a given key key. If the key already exists, its value is **overridden**.\n\n ```aiken\n dict.new()\n |&gt; dict.insert(key: foo, value: &quot;Foo&quot;, bytearray.compare)\n |&gt; dict.insert(key: foo, value: &quot;Aiken&quot;, bytearray.compare)\n |&gt; dict.to_list()\n // [(foo, &quot;Aiken&quot;)]\n ```","url":"aiken/dict.html#insert"},{"doc":"aiken/dict","title":"is_empty","content":"is_empty(self: Dict&lt;key, value&gt;) -&gt; Bool\n Efficiently checks whether a dictionnary is empty.","url":"aiken/dict.html#is_empty"},{"doc":"aiken/dict","title":"keys","content":"keys(self: Dict&lt;key, value&gt;) -&gt; List&lt;key&gt;\n Extract all the keys present in a given `Dict`.\n\n ```aiken\n dict.new()\n |&gt; dict.insert(foo, 14, bytearray.compare)\n |&gt; dict.insert(bar, 42, bytearray.compare)\n |&gt; dict.insert(foo, 1337, bytearray.compare)\n |&gt; dict.keys()\n // [foo, bar]\n ```","url":"aiken/dict.html#keys"},{"doc":"aiken/dict","title":"map","content":"map(self: Dict&lt;key, a&gt;, with: fn(key, a) -&gt; b) -&gt; Dict&lt;key, b&gt;\n Apply a function to all key-value pairs in a map.\n\n ```aiken\n pub fn celebrate_birthday(self: Dict&lt;ByteArray, Int&gt;, key: ByteArray) {\n   dict.map(self, with: fn(_key, value) { value + 1 })\n }\n ```","url":"aiken/dict.html#map"},{"doc":"aiken/dict","title":"new","content":"new() -&gt; Dict&lt;key, value&gt;\n Create a new map","url":"aiken/dict.html#new"},{"doc":"aiken/dict","title":"size","content":"size(self: Dict&lt;key, value&gt;) -&gt; Int\n Return the number of key-value pairs in the dictionnary.","url":"aiken/dict.html#size"},{"doc":"aiken/dict","title":"to_list","content":"to_list(self: Dict&lt;key, value&gt;) -&gt; List&lt;(key, value)&gt;\n Get the inner list holding the dictionnary data.","url":"aiken/dict.html#to_list"},{"doc":"aiken/dict","title":"union","content":"union(\n  left: Dict&lt;key, value&gt;,\n  right: Dict&lt;key, value&gt;,\n  compare: fn(key, key) -&gt; Ordering,\n) -&gt; Dict&lt;key, value&gt;\n Combine two dictionnaries. If the same key exist in both the left and\n right dictionnary, values from the left are preferred (i.e. left-biaised).","url":"aiken/dict.html#union"},{"doc":"aiken/dict","title":"union_with","content":"union_with(\n  left: Dict&lt;key, value&gt;,\n  right: Dict&lt;key, value&gt;,\n  with: fn(key, value, value) -&gt; Option&lt;value&gt;,\n  compare: fn(key, key) -&gt; Ordering,\n) -&gt; Dict&lt;key, value&gt;\n Like [`union`](#union) but allows specifying the behavior to adopt when a key is present\n in both dictionnaries.\n\n When passing `None`, the value is removed and not present in the union.","url":"aiken/dict.html#union_with"},{"doc":"aiken/dict","title":"values","content":"values(self: Dict&lt;key, value&gt;) -&gt; List&lt;value&gt;\n Combine two dictionnaries using the provided strategy for combining values when the same\n key is found in both dictionnaries.\n Extract all the values present in a given `Dict`.\n\n ```aiken\n use aiken.dict\n\n dict.new()\n |&gt; dict.insert(foo, 14, bytearray.compare)\n |&gt; dict.insert(bar, 42, bytearray.compare)\n |&gt; dict.insert(foo, 1337, bytearray.compare)\n |&gt; dict.values()\n // [42, 1337]\n ```","url":"aiken/dict.html#values"},{"doc":"aiken/dict","title":"Dict","content":"Dict&lt;key, value&gt;\n An opaque `Dict`. The type is opaque because the module maintains some\n invariant, namely: there&#39;s only one occurence of a given key in the dictionnary.\n\n Note that the `key` parameter is a phantom-type, and only present as a\n means of documentation. Keys can be any type, yet will need to comparable\n to use functions like `insert`.\n\n See for example:\n\n ```aiken\n pub type Value =\n   Dict&lt;PolicyId, Dict&lt;AssetName, Int&gt;&gt;\n ```\n","url":"aiken/dict.html#Dict"},{"doc":"aiken/dict","title":"aiken/dict","content":" A module for working with bytearray dictionnaries.\n\n These dictionnaries are fundamentally ordered lists of key-value pairs,\n which preserve some invariants. In particular, each key is only present\n once in the dictionnary.","url":"aiken/dict.html"},{"doc":"aiken/cbor","title":"diagnostic","content":"diagnostic(self: Data) -&gt; String\n Obtain a String representation of _anything_. This is particularly (and only) useful for tracing\n and debugging. This function is expensive and should not be used in any production code as it\n will very likely explodes the validator&#39;s budget.\n\n The output is a [CBOR diagnostic](https://www.rfc-editor.org/rfc/rfc8949#name-diagnostic-notation)\n of the underlying on-chain binary representation of the data. It&#39;s not as\n easy to read as plain Aiken code, but it is handy for troubleshooting values\n _at runtime_. Incidentally, getting familiar with reading CBOR diagnostic is\n a good idea in the Cardano world.\n\n ```aiken\n diagnostic(42) == &quot;42&quot;\n diagnostic(#&quot;a1b2&quot;) == &quot;h&#39;A1B2&#39;&quot;\n diagnostic([1, 2, 3]) == &quot;[1, 2, 3]&quot;\n diagnostic([]) == &quot;[]&quot;\n diagnostic((1, 2)) == &quot;[1, 2]&quot;\n diagnostic((1, #&quot;ff&quot;, 3)) == &quot;[1, h&#39;FF&#39;, 3]&quot;\n diagnostic([(1, #&quot;ff&quot;)]) == &quot;{ 1: h&#39;FF&#39; }&quot;\n diagnostic(Some(42)) == &quot;121([42])&quot;\n diagnostic(None) == &quot;122([])&quot;\n ```","url":"aiken/cbor.html#diagnostic"},{"doc":"aiken/cbor","title":"serialise","content":"serialise(self: Data) -&gt; ByteArray\n Serialise any value to binary, encoding using [CBOR](https://www.rfc-editor.org/rfc/rfc8949).\n\n This is particularly useful in combination with hashing functions, as a way\n to obtain a byte representation that matches the serialised representation\n used by the ledger in the context of on-chain code.\n\n Note that the output matches the output of [`diagnostic`](#diagnostic),\n though with a different encoding. [`diagnostic`](#diagnostic) is merely a\n textual representation of the CBOR encoding that is human friendly and\n useful for debugging.\n\n ```aiken\n serialise(42) == #&quot;182a&quot;\n serialise(#&quot;a1b2&quot;) == #&quot;42a1b2&quot;\n serialise([]) == #&quot;80&quot;\n serialise((1, 2)) == #&quot;9f0102ff&quot;\n serialise((1, #&quot;ff&quot;, 3)) == #&quot;9f0141ff03ff&quot;\n serialise([(1, #&quot;ff&quot;)]) == #&quot;a10141ff&quot;\n serialise(Some(42)) == #&quot;d8799f182aff&quot;\n serialise(None) == #&quot;d87a80&quot;\n ```","url":"aiken/cbor.html#serialise"},{"doc":"aiken/cbor","title":"aiken/cbor","content":"","url":"aiken/cbor.html"}]);